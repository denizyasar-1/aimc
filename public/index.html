<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Multiplayer PvP Oyun</title>
<style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #111; }
    #ui { position: fixed; inset: 0 auto auto 0; color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; pointer-events: none; }
    .panel { position: absolute; left: 16px; top: 16px; background: rgba(0,0,0,.55); padding: 12px 14px; border-radius: 14px; backdrop-filter: blur(6px); border: 1px solid rgba(255,255,255,.08); pointer-events: auto; }
    .panel h1 { font-size: 14px; margin: 0 0 8px; letter-spacing: .3px; font-weight: 700; }
    .panel p { margin: 4px 0; font-size: 12px; line-height: 1.45; opacity: .95; }
    .hotbar { position: absolute; left: 50%; bottom: 18px; transform: translateX(-50%); display: grid; grid-auto-flow: column; gap: 8px; }
    .slot { width: 46px; height: 46px; border-radius: 10px; border: 1px solid rgba(255,255,255,.15); background: rgba(0,0,0,.35); display: grid; place-content: center; color: #fff; font-weight: 700; }
    .slot.active { outline: 2px solid #fff; outline-offset: 2px; }
    .crosshair { position: absolute; left: 50%; top: 50%; width: 14px; height: 14px; transform: translate(-50%, -50%); }
    .crosshair::before, .crosshair::after { content: ""; position: absolute; background: #fff; opacity: .8; }
    .crosshair::before { left: 6px; top: 0; width: 2px; height: 14px; }
    .crosshair::after { top: 6px; left: 0; height: 2px; width: 14px; }
    .hint { position: absolute; right: 16px; bottom: 16px; color: #9ae6b4; font-size: 12px; background: rgba(0,0,0,.4); padding: 8px 10px; border-radius: 10px; border: 1px solid rgba(255,255,255,.08); }
    canvas { display: block; }
    .badge { display:inline-block; padding:2px 6px; border-radius:6px; background:#2d3748; font-size:11px; margin-left:6px; border:1px solid rgba(255,255,255,.12);}
    
    #inventory {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid #555;
      border-radius: 8px;
      padding: 20px;
      display: none;
      z-index: 1000;
      backdrop-filter: blur(4px);
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
    }
    #inventory.visible { display: block; }
    .inventory-title { color: white; text-align: center; margin-bottom: 15px; font-size: 18px; font-weight: bold; }
    .inventory-grid { display: grid; grid-template-columns: repeat(9, 1fr); gap: 8px; max-width: 500px; }
    .inventory-slot {
      width: 50px; height: 50px; background: rgba(100, 100, 100, 0.3); border: 1px solid #666; border-radius: 4px;
      display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; cursor: pointer;
      position: relative; transition: all 0.2s;
    }
    .inventory-slot:hover { background: rgba(150, 150, 150, 0.5); transform: scale(1.05); }
    .inventory-slot.selected { border: 2px solid #fff; box-shadow: 0 0 10px rgba(255, 255, 255, 0.5); }
    .item-count { position: absolute; bottom: 2px; right: 4px; font-size: 12px; color: #fff; }
    .close-inventory { position: absolute; top: 10px; right: 10px; background: #ff4444; color: white; border: none; border-radius: 4px; padding: 5px 10px; cursor: pointer; font-size: 12px; }
    .close-inventory:hover { background: #ff6666; }
    
    #break-progress {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100px; height: 8px;
      background: rgba(0, 0, 0, 0.5); border-radius: 4px; display: none; z-index: 100;
    }
    #break-progress-bar { height: 100%; background: #ff5555; border-radius: 4px; width: 0%; transition: width 0.1s; }
    
    #debug-info { position: fixed; top: 16px; right: 16px; background: rgba(0,0,0,.55); color: #fff; padding: 8px 12px; border-radius: 8px; font-size: 12px; font-family: monospace; }
    #multiplayer-info { position: fixed; top: 60px; right: 16px; background: rgba(0,0,0,.55); color: #fff; padding: 8px 12px; border-radius: 8px; font-size: 12px; font-family: monospace; }
    
    .remote-player-label {
      position: absolute; background: rgba(0,0,0,.7); color: white; padding: 2px 6px; border-radius: 4px;
      font-size: 10px; pointer-events: none; transform: translate(-50%, -30px); z-index: 10;
    }
    .health-bar { position: absolute; width: 40px; height: 5px; background: #444; border-radius: 2px; overflow: hidden; z-index: 10; }
    .health-fill { height: 100%; background: #ff5555; transition: width 0.3s; }
    
    #attack-mode-indicator {
      position: fixed; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(255, 0, 0, 0.7);
      color: white; padding: 5px 15px; border-radius: 15px; font-size: 14px; display: none; z-index: 100;
    }

    #connection-debug {
      position: fixed; top: 110px; right: 16px; background: rgba(0,0,0,.55); color: #fff; 
      padding: 8px 12px; border-radius: 8px; font-size: 11px; font-family: monospace; max-width: 200px;
    }
</style>
</head>
<body>
  <div id="ui">
    <div class="panel" id="help">
      <h1>Mini Minecraft (Çok Oyunculu) <span class="badge">64x64 Dünya</span></h1>
      <p><b>Bakınma:</b> fareyi <u>basılı tutup sürükle</u>.</p>
      <p><b>W A S D</b>: yürü — <b>Space</b>: zıpla — <b>Shift</b>: hızlı koş</p>
      <p><b>Sol tık basılı tut</b>: blok kır — <b>Sağ tık</b>: blok yerleştir</p>
      <p><b>1-8</b>: Blok seçimi</p>
      <p><b>R</b>: rastgele ağaçlar — <b>G</b>: sis aç/kapat</p>
      <p><b>E</b>: envanter — <b>Q</b>: Saldırı modu</p>
      <p style="opacity:.8">Çok oyunculu test modu!</p>
    </div>
    <div class="hotbar" id="hotbar"></div>
    <div class="crosshair"></div>
    <div class="hint">İpucu: Şu an tek oyunculu modda!</div>
  </div>
  
  <div id="break-progress"><div id="break-progress-bar"></div></div>
  <div id="debug-info">FPS: <span id="fps-counter">0</span> | Chunks: <span id="chunk-counter">0</span> | Blocks: <span id="block-counter">0</span></div>
  <div id="multiplayer-info">Oyuncular: <span id="player-count">1</span> | Durum: <span id="connection-status">Tek Oyunculu</span></div>
  <div id="connection-debug">Socket: Yok<br>Server: Yok</div>
  <div id="inventory">
    <div class="inventory-title">Envanter</div>
    <button class="close-inventory" onclick="toggleInventory()">Kapat (E)</button>
    <div class="inventory-grid" id="inventoryGrid"></div>
  </div>
  <div id="attack-mode-indicator">SALDIRI MODU</div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    console.log('Oyun başlatılıyor...');
    
    // === Envanter Sistemi ===
    let inventoryVisible = false;
    let inventoryItems = {};
    let selectedInventorySlot = 0;
    const inventoryElement = document.getElementById('inventory');
    const inventoryGrid = document.getElementById('inventoryGrid');

    function createInventory() {
      inventoryGrid.innerHTML = '';
      for (let i = 0; i < 27; i++) {
        const slot = document.createElement('div');
        slot.className = 'inventory-slot';
        slot.dataset.index = i;
        slot.addEventListener('click', () => selectInventorySlot(i));
        inventoryGrid.appendChild(slot);
      }
      
      BLOCK_TYPES.forEach((type, index) => {
        inventoryItems[index] = 16;
      });
      updateInventoryDisplay();
    }

    function updateInventoryDisplay() {
      const slots = inventoryGrid.querySelectorAll('.inventory-slot');
      slots.forEach((slot, index) => {
        const typeIndex = Math.floor(index / 9);
        const type = BLOCK_TYPES[typeIndex];
        if (type && index < BLOCK_TYPES.length * 3) {
          slot.textContent = type.label;
          slot.style.backgroundColor = `rgba(${(type.colorTop >> 16) & 0xFF}, ${(type.colorTop >> 8) & 0xFF}, ${type.colorTop & 0xFF}, 0.3)`;
        }
      });
    }

    function selectInventorySlot(index) {
      selectedInventorySlot = index;
      const slots = inventoryGrid.querySelectorAll('.inventory-slot');
      slots.forEach((slot, i) => {
        slot.classList.toggle('selected', i === index);
      });
      
      const blockTypeIndex = Math.floor(index / 9);
      if (blockTypeIndex < BLOCK_TYPES.length) {
        currentBlockType = blockTypeIndex;
        updateHotbar();
      }
    }

    function toggleInventory() {
      inventoryVisible = !inventoryVisible;
      inventoryElement.classList.toggle('visible', inventoryVisible);
      if (inventoryVisible) {
        if (document.pointerLockElement === renderer.domElement) {
          document.exitPointerLock();
        }
        stopBreakingBlock();
      } else {
        renderer.domElement.requestPointerLock();
      }
    }

    // === Kontroller ===
    const keys = { w:false, a:false, s:false, d:false, shift:false };

    addEventListener('keydown', e=>{
      if (inventoryVisible) {
        if (e.code === 'KeyE') {
          e.preventDefault();
          toggleInventory();
        }
        return;
      }

      if (e.code === 'KeyW') keys.w = true; 
      else if (e.code === 'KeyA') keys.a = true; 
      else if (e.code === 'KeyS') keys.s = true; 
      else if (e.code === 'KeyD') keys.d = true; 
      else if (e.code === 'ShiftLeft') keys.shift = true;
      else if (e.code === 'Space') { 
        if (canJump) { 
          velocity.y = 12; 
          canJump = false; 
        } 
      }
      else if (e.code === 'Digit1') { currentBlockType = 0; updateHotbar(); } 
      else if (e.code === 'Digit2') { currentBlockType = 1; updateHotbar(); } 
      else if (e.code === 'Digit3') { currentBlockType = 2; updateHotbar(); } 
      else if (e.code === 'Digit4') { currentBlockType = 3; updateHotbar(); }
      else if (e.code === 'Digit5') { currentBlockType = 4; updateHotbar(); }
      else if (e.code === 'Digit6') { currentBlockType = 5; updateHotbar(); }
      else if (e.code === 'Digit7') { currentBlockType = 6; updateHotbar(); }
      else if (e.code === 'Digit8') { currentBlockType = 7; updateHotbar(); }
      else if (e.code === 'KeyG') { 
        scene.fog ? (scene.fog=null) : (scene.fog = new THREE.Fog(0x87ceeb, 20, 60)); 
      }
      else if (e.code === 'KeyR') { 
        const x = Math.floor(player.position.x + (Math.random() - 0.5) * 20);
        const z = Math.floor(player.position.z + (Math.random() - 0.5) * 20);
        addTree(x, z);
      }
      else if (e.code === 'KeyE') { 
        e.preventDefault();
        toggleInventory(); 
      }
      else if (e.code === 'KeyQ') {
        e.preventDefault();
        toggleAttackMode();
      }
    });

    addEventListener('keyup', e=>{
      if (inventoryVisible) return;
      if (e.code === 'KeyW') keys.w = false; 
      else if (e.code === 'KeyA') keys.a = false; 
      else if (e.code === 'KeyS') keys.s = false; 
      else if (e.code === 'KeyD') keys.d = false; 
      else if (e.code === 'ShiftLeft') keys.shift = false;
    });

    // Saldırı modu geçişi
    function toggleAttackMode() {
      attackMode = !attackMode;
      swordMesh.visible = attackMode;
      attackModeIndicator.style.display = attackMode ? 'block' : 'none';
    }

    // Mouse kontrolleri
    let lookActive = false, movedDuringDrag = false, lastX = 0, lastY = 0, yaw = 0, pitch = 0;
    let mouseDown = false;

    renderer.domElement.addEventListener('mousedown', (e)=>{
      if (inventoryVisible) return;
      
      if (e.button === 0) {
        if (attackMode) {
          // Saldırı modu
          console.log('Saldırı!');
        } else {
          // Blok kırma
          mouseDown = true;
          const hit = getTargetBlock();
          if (hit) {
            startBreakingBlock(hit.x, hit.y, hit.z);
          }
        }
      }
      
      lookActive = true; 
      movedDuringDrag = false; 
      lastX = e.clientX; 
      lastY = e.clientY; 
    });

    addEventListener('mouseup', (e)=>{
      if (inventoryVisible) return;
      
      if (e.button === 0) {
        mouseDown = false;
        stopBreakingBlock();
      }
      
      if (!movedDuringDrag && e.button !== 0) handleBlockClick(e); 
      lookActive = false; 
    });

    addEventListener('mousemove', (e)=>{
      if (inventoryVisible || !lookActive) return;
      
      const dx = e.clientX - lastX; 
      const dy = e.clientY - lastY;
      
      if (Math.abs(dx) > 1 || Math.abs(dy) > 1) movedDuringDrag = true;
      
      lastX = e.clientX; 
      lastY = e.clientY;
      yaw -= dx * 0.0028; 
      pitch -= dy * 0.0028;
      pitch = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, pitch));
      
      player.rotation.y = yaw; 
      camera.rotation.x = pitch;
    });

    addEventListener('contextmenu', e=> e.preventDefault());

    // === Blok işlemleri ===
    const raycaster = new THREE.Raycaster();

    function getTargetBlock(){
      raycaster.setFromCamera({x:0, y:0}, camera);
      const intersects = raycaster.intersectObjects([...allBlocks.values()], false);
      
      if (intersects.length > 0) {
        const inter = intersects[0];
        const p = inter.object.position.clone().addScalar(-0.5);
        return { 
          x: Math.round(p.x), 
          y: Math.round(p.y), 
          z: Math.round(p.z), 
          normal: inter.face.normal.clone() 
        };
      }
      return null;
    }

    function handleBlockClick(e){
      if (inventoryVisible) return;
      
      const hit = getTargetBlock();
      if (!hit) return;

      if (e.button === 2){
        const nx = hit.x + hit.normal.x;
        const ny = hit.y + hit.normal.y; 
        const nz = hit.z + hit.normal.z;
        
        const playerBox = new THREE.Box3().setFromCenterAndSize(
          player.position, 
          new THREE.Vector3(0.6, 1.6, 0.6)
        );
        const blockBox = new THREE.Box3().setFromCenterAndSize(
          new THREE.Vector3(nx+0.5, ny+0.5, nz+0.5), 
          new THREE.Vector3(1,1,1)
        );
        
        if(!playerBox.intersectsBox(blockBox) && ny < WORLD_HEIGHT && ny >= 0) {
          addBlock(nx, ny, nz, currentBlockType);
        }
      }
    }

    function isBlockAt(x, y, z) {
      return allBlocks.has(posKey(Math.floor(x), Math.floor(y), Math.floor(z)));
    }

    // Ağaç ekleme
    function addTree(tx, tz) {
      let baseY = 0;
      for (let y = WORLD_HEIGHT - 1; y >= 0; y--) {
        if (allBlocks.has(posKey(tx, y, tz))) {
          baseY = y + 1;
          break;
        }
      }
      
      if (baseY < 7 || baseY > 9) return;

      const height = 3 + Math.floor(Math.random() * 2);
      for (let i = 0; i < height; i++) {
        if (baseY + i < WORLD_HEIGHT) {
          const chunkCoords = getChunkCoords(tx, tz);
          const chunk = getChunk(chunkCoords.cx, chunkCoords.cz);
          chunk.addBlock(tx, baseY + i, tz, 3);
        }
      }

      const cy = baseY + height;
      const leaves = [
        [0,0,0],[1,0,0],[-1,0,0],[0,0,1],[0,0,-1],
        [1,0,1],[1,0,-1],[-1,0,1],[-1,0,-1],
        [0,1,0],[1,1,0],[-1,1,0],[0,1,1],[0,1,-1]
      ];
      
      leaves.forEach(([dx,dy,dz])=> {
        if (Math.random() > 0.3 && cy+dy < WORLD_HEIGHT) {
          const chunkCoords = getChunkCoords(tx+dx, tz+dz);
          const chunk = getChunk(chunkCoords.cx, chunkCoords.cz);
          chunk.addBlock(tx+dx, cy+dy, tz+dz, 0);
        }
      });
    }

    // === Fizik ve hareket ===
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const up = new THREE.Vector3(0,1,0);
    let canJump = false;
    const clock = new THREE.Clock();

    // Debug bilgisi
    const fpsCounter = document.getElementById('fps-counter');
    const chunkCounter = document.getElementById('chunk-counter');
    const blockCounter = document.getElementById('block-counter');
    let frameCount = 0;
    let lastFpsUpdate = 0;

    // Ana animasyon döngüsü
    function animate(){
      requestAnimationFrame(animate);

      if (inventoryVisible) {
        renderer.render(scene, camera);
        return;
      }

      const delta = Math.min(0.05, clock.getDelta());
      const elapsedTime = clock.getElapsedTime();

      // FPS hesaplama
      frameCount++;
      if (elapsedTime - lastFpsUpdate >= 1) {
        fpsCounter.textContent = frameCount;
        chunkCounter.textContent = loadedChunks.size;
        blockCounter.textContent = allBlocks.size;
        frameCount = 0;
        lastFpsUpdate = elapsedTime;
      }

      // Chunk sistemini güncelle
      updateLoadedChunks();

      // Kırılma ilerlemesi
      if (mouseDown && breakingBlock) {
        updateBreakingProgress();
      }

      // Uzak oyuncuların etiketlerini güncelle
      updateRemotePlayerLabels();

      // Yürüme yönü
      const forward = new THREE.Vector3(0,0,-1).applyAxisAngle(up, yaw);
      const right = new THREE.Vector3().crossVectors(up, forward);
      direction.set(0,0,0);
      
      if (keys.w) direction.add(forward); 
      if (keys.s) direction.sub(forward);
      if (keys.a) direction.add(right); 
      if (keys.d) direction.sub(right);
      
      if (direction.lengthSq() > 0) direction.normalize();

      const speed = (keys.shift ? 8 : 4);
      velocity.x = direction.x * speed;
      velocity.z = direction.z * speed;
      velocity.y -= 20 * delta;

      // Çarpışma fiziği
      const playerWidth = 0.2;
      const playerHeight = 1.5;
      const pos = player.position;

      // X ekseni hareketi
      const newX = pos.x + velocity.x * delta;
      if (!isBlockAt(newX + (velocity.x > 0 ? playerWidth : -playerWidth), pos.y, pos.z) &&
          !isBlockAt(newX + (velocity.x > 0 ? playerWidth : -playerWidth), pos.y + 1, pos.z)) {
        pos.x = newX;
      }

      // Z ekseni hareketi
      const newZ = pos.z + velocity.z * delta;
      if (!isBlockAt(pos.x, pos.y, newZ + (velocity.z > 0 ? playerWidth : -playerWidth)) &&
          !isBlockAt(pos.x, pos.y + 1, newZ + (velocity.z > 0 ? playerWidth : -playerWidth))) {
        pos.z = newZ;
      }

      // Y ekseni hareketi (yerçekimi)
      const newY = pos.y + velocity.y * delta;
      if (velocity.y <= 0) {
        const footY = newY;
        if (isBlockAt(pos.x, footY, pos.z)) {
          pos.y = Math.floor(footY) + 1;
          velocity.y = 0;
          canJump = true;
        } else {
          pos.y = newY;
        }
      } else {
        const headY = newY + playerHeight;
        if (isBlockAt(pos.x, headY, pos.z)) {
          pos.y = Math.floor(headY) - playerHeight;
          velocity.y = 0;
        } else {
          pos.y = newY;
        }
      }

      // Blok vurgulama
      const target = getTargetBlock();
      if (target) {
        highlightMesh.position.set(target.x + 0.5, target.y + 0.5, target.z + 0.5);
        highlightMesh.visible = true;
      } else {
        highlightMesh.visible = false;
      }

      renderer.render(scene, camera);
    }

    // Uzak oyuncu etiketlerini güncelleme
    function updateRemotePlayerLabels() {
      remotePlayers.forEach((remotePlayer) => {
        const vector = remotePlayer.group.position.clone(); 
        vector.y += 1.3;
        vector.project(camera);
        
        const x = (vector.x * 0.5 + 0.5) * innerWidth;
        const y = (-vector.y * 0.5 + 0.5) * innerHeight;
        
        remotePlayer.label.style.left = x + 'px';
        remotePlayer.label.style.top = y + 'px';
        remotePlayer.label.style.display = vector.z < 1 ? 'block' : 'none';
        
        if (remotePlayer.healthBar) {
          remotePlayer.healthBar.style.left = (x - 20) + 'px';
          remotePlayer.healthBar.style.top = (y - 15) + 'px';
          remotePlayer.healthBar.style.display = vector.z < 1 ? 'block' : 'none';
        }
      });
    }

    // === Başlangıç ===
    console.log('Chunk sistem başlatılıyor...');
    
    // Başlangıç chunk'larını yükle
    function loadInitialChunks() {
      const playerChunkX = Math.floor(player.position.x / CHUNK_SIZE);
      const playerChunkZ = Math.floor(player.position.z / CHUNK_SIZE);
      
      for (let cx = playerChunkX - 1; cx <= playerChunkX + 1; cx++) {
        for (let cz = playerChunkZ - 1; cz <= playerChunkZ + 1; cz++) {
          if (cx >= 0 && cz >= 0 && cx < CHUNKS_X && cz < CHUNKS_Z) {
            loadChunk(cx, cz);
          }
        }
      }
      console.log('Başlangıç chunk\'ları yüklendi');
    }

    // Dünya başlatma
    try {
      loadInitialChunks();
      createInventory();
      
      // Test için bazı ağaçlar ekle
      for (let i = 0; i < 10; i++) {
        const x = Math.floor(Math.random() * WORLD_SIZE);
        const z = Math.floor(Math.random() * WORLD_SIZE);
        addTree(x, z);
      }
      
      console.log('Dünya oluşturuldu');
      
      // Çok oyunculu sistem başlat
      initializeMultiplayer();
      
      // Animasyon başlat
      animate();
      
      console.log('Oyun başlatıldı!');
      
    } catch (error) {
      console.error('Oyun başlatma hatası:', error);
      document.body.innerHTML = '<div style="color:white;padding:20px;">Oyun başlatılamadı: ' + error.message + '</div>';
    }

    // Pencere yeniden boyutlandırma
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Global toggleInventory fonksiyonu
    window.toggleInventory = toggleInventory;

    console.log('Tüm event listener\'lar eklendi');
  </script>
</body>
</html> Temel Ayarlar ===
    const WORLD_SIZE = 64;
    const WORLD_HEIGHT = 10;
    const CHUNK_SIZE = 16;
    const RENDER_DISTANCE = 1;
    const BLOCK = 1;
    let currentBlockType = 0;
    let playerId = 'player_' + Math.random().toString(36).substr(2, 9);
    
    // Saldırı modu
    let attackMode = false;
    const attackModeIndicator = document.getElementById('attack-mode-indicator');
    
    // Chunk hesaplama
    const CHUNKS_X = Math.ceil(WORLD_SIZE / CHUNK_SIZE);
    const CHUNKS_Z = Math.ceil(WORLD_SIZE / CHUNK_SIZE);
    
    // Blok tipleri
    const BLOCK_TYPES = [
      { key: 'grass', label: '1', colorTop: 0x6abf69, colorSide: 0x4d9b4b, breakTime: 0.8 },
      { key: 'dirt',  label: '2', colorTop: 0x8b5a2b, colorSide: 0x6f4620, breakTime: 0.6 },
      { key: 'stone', label: '3', colorTop: 0x9aa0a6, colorSide: 0x7a8086, breakTime: 1.5 },
      { key: 'wood',  label: '4', colorTop: 0xcaa472, colorSide: 0xa17f5b, breakTime: 1.0 },
      { key: 'coal',  label: '5', colorTop: 0x2d2d2d, colorSide: 0x1a1a1a, breakTime: 2.0 },
      { key: 'iron',  label: '6', colorTop: 0xd8d8d8, colorSide: 0xb0b0b0, breakTime: 2.5 },
      { key: 'gold',  label: '7', colorTop: 0xffd700, colorSide: 0xe6c200, breakTime: 2.0 },
      { key: 'diamond',label: '8',colorTop: 0x00ffff, colorSide: 0x00cccc, breakTime: 3.0 },
    ];

    // Hotbar UI
    const hotbar = document.getElementById('hotbar');
    BLOCK_TYPES.forEach((t, i) => {
      const el = document.createElement('div');
      el.className = 'slot' + (i === currentBlockType ? ' active' : '');
      el.textContent = t.label;
      el.dataset.index = i;
      hotbar.appendChild(el);
    });
    const updateHotbar = () => { [...hotbar.children].forEach((c, i) => c.classList.toggle('active', i === currentBlockType)); };

    console.log('UI hazırlandı, THREE.js kontrol ediliyor...');

    // THREE.js kontrol
    if (typeof THREE === 'undefined') {
      console.error('THREE.js yüklenemedi!');
      document.body.innerHTML = '<div style="color:white;padding:20px;">THREE.js yüklenemedi!</div>';
    } else {
      console.log('THREE.js yüklendi, sahne oluşturuluyor...');
    }

    // === THREE.js Kurulum ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 20, 60);
    
    const camera = new THREE.PerspectiveCamera(75, innerWidth / innerHeight, 0.1, 100);
    const player = new THREE.Object3D();
    player.position.set(WORLD_SIZE / 2, 5, WORLD_SIZE / 2);
    camera.position.set(0, 1.6, 0);
    player.add(camera);
    scene.add(player);

    const renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setPixelRatio(1);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    console.log('Renderer oluşturuldu');

    // Işıklar
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(40, 60, 20);
    scene.add(dir);

    // Hedef bloğu vurgulama
    const highlightGeo = new THREE.BoxGeometry(1.002, 1.002, 1.002);
    const highlightMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.25, depthWrite: false });
    const highlightMesh = new THREE.Mesh(highlightGeo, highlightMat);
    scene.add(highlightMesh);

    // Kılıç
    const swordGeometry = new THREE.BoxGeometry(0.1, 1, 0.1);
    const swordMaterial = new THREE.MeshLambertMaterial({ color: 0xc0c0c0 });
    const swordMesh = new THREE.Mesh(swordGeometry, swordMaterial);
    swordMesh.position.set(0.3, -0.5, -0.5);
    swordMesh.rotation.x = Math.PI / 2;
    swordMesh.visible = false;
    camera.add(swordMesh);

    console.log('Temel THREE.js nesneleri oluşturuldu');

    // === Çok Oyunculu Sistem (Simüle Edilmiş) ===
    let socket = null;
    const remotePlayers = new Map();
    let lastPositionSend = 0;

    // Simüle edilmiş çok oyunculu sistem
    function initializeMultiplayer() {
      document.getElementById('connection-status').textContent = 'Simülasyon Modu';
      document.getElementById('connection-debug').innerHTML = 'Socket: Simüle<br>Mod: Test';
      
      // Test için sahte oyuncu ekle
      setTimeout(() => {
        addRemotePlayer({
          id: 'test_player_1',
          username: 'Test Oyuncu',
          x: player.position.x + 5,
          y: player.position.y,
          z: player.position.z + 5,
          yaw: 0,
          pitch: 0,
          attackMode: false,
          health: 100
        });
        updatePlayerCount();
        
        // Test oyuncusunu hareket ettir
        setInterval(() => {
          const testPlayer = remotePlayers.get('test_player_1');
          if (testPlayer) {
            testPlayer.group.position.x += (Math.random() - 0.5) * 0.1;
            testPlayer.group.position.z += (Math.random() - 0.5) * 0.1;
          }
        }, 1000);
      }, 2000);
    }

    function updatePlayerCount() {
      document.getElementById('player-count').textContent = remotePlayers.size + 1;
    }

    function addRemotePlayer(playerData) {
      console.log('Uzak oyuncu ekleniyor:', playerData);
      
      if (remotePlayers.has(playerData.id)) return;

      const playerGroup = new THREE.Group();
      
      // Gövde
      const bodyGeometry = new THREE.BoxGeometry(0.6, 0.9, 0.3);
      const bodyMaterial = new THREE.MeshLambertMaterial({ 
        color: playerData.attackMode ? 0xff0000 : 0x0000ff 
      });
      const bodyMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
      bodyMesh.position.y = 0.45;
      playerGroup.add(bodyMesh);
      
      // Kafa
      const headGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
      const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffcc99 });
      const headMesh = new THREE.Mesh(headGeometry, headMaterial);
      headMesh.position.y = 1.1;
      playerGroup.add(headMesh);
      
      // Kollar
      const armGeometry = new THREE.BoxGeometry(0.15, 0.7, 0.15);
      const armMaterial = new THREE.MeshLambertMaterial({ color: 0x000088 });
      const leftArmMesh = new THREE.Mesh(armGeometry, armMaterial);
      leftArmMesh.position.set(-0.4, 0.45, 0);
      playerGroup.add(leftArmMesh);
      const rightArmMesh = new THREE.Mesh(armGeometry, armMaterial);
      rightArmMesh.position.set(0.4, 0.45, 0);
      playerGroup.add(rightArmMesh);
      
      // Ayaklar
      const legGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
      const legMaterial = new THREE.MeshLambertMaterial({ color: 0x000088 });
      const leftLegMesh = new THREE.Mesh(legGeometry, legMaterial);
      leftLegMesh.position.set(-0.15, -0.4, 0);
      playerGroup.add(leftLegMesh);
      const rightLegMesh = new THREE.Mesh(legGeometry, legMaterial);
      rightLegMesh.position.set(0.15, -0.4, 0);
      playerGroup.add(rightLegMesh);
      
      playerGroup.position.set(playerData.x || 0, playerData.y || 5, playerData.z || 0);
      if (playerData.yaw !== undefined) {
        playerGroup.rotation.y = playerData.yaw;
      }
      
      scene.add(playerGroup);
      
      // Oyuncu etiketi
      const label = document.createElement('div');
      label.className = 'remote-player-label';
      label.textContent = playerData.username || 'Oyuncu';
      document.body.appendChild(label);
      
      // Can barı
      const healthBar = document.createElement('div');
      healthBar.className = 'health-bar';
      healthBar.innerHTML = '<div class="health-fill"></div>';
      healthBar.style.display = 'none';
      document.body.appendChild(healthBar);
      
      remotePlayers.set(playerData.id, {
        group: playerGroup,
        label: label,
        healthBar: healthBar,
        playerData: playerData,
        health: playerData.health || 100,
        bodyMesh: bodyMesh
      });

      console.log('Uzak oyuncu eklendi:', playerData.id);
    }

    function updateRemotePlayer(playerData) {
      const remotePlayer = remotePlayers.get(playerData.id);
      if (!remotePlayer) {
        addRemotePlayer(playerData);
        return;
      }

      remotePlayer.group.position.set(
        playerData.x || remotePlayer.group.position.x, 
        playerData.y || remotePlayer.group.position.y, 
        playerData.z || remotePlayer.group.position.z
      );
      
      if (playerData.yaw !== undefined) {
        remotePlayer.group.rotation.y = playerData.yaw;
      }
      
      if (playerData.attackMode !== undefined) {
        remotePlayer.bodyMesh.material.color.setHex(playerData.attackMode ? 0xff0000 : 0x0000ff);
      }

      if (playerData.health !== undefined) {
        remotePlayer.health = playerData.health;
        updateHealthBar(remotePlayer);
      }

      remotePlayer.playerData = playerData;
    }

    function removeRemotePlayer(playerId) {
      const remotePlayer = remotePlayers.get(playerId);
      if (remotePlayer) {
        scene.remove(remotePlayer.group);
        document.body.removeChild(remotePlayer.label);
        if (remotePlayer.healthBar) {
          document.body.removeChild(remotePlayer.healthBar);
        }
        remotePlayers.delete(playerId);
      }
    }

    function updateHealthBar(remotePlayer) {
      if (remotePlayer.healthBar) {
        const healthFill = remotePlayer.healthBar.querySelector('.health-fill');
        const healthPercent = (remotePlayer.health / 100) * 100;
        healthFill.style.width = healthPercent + '%';
      }
    }

    // === Chunk Sistemi ===
    const chunks = new Map();
    const loadedChunks = new Set();
    const allBlocks = new Map();
    const posKey = (x, y, z) => `${x},${y},${z}`;
    const chunkKey = (cx, cz) => `${cx},${cz}`;
    const boxGeo = new THREE.BoxGeometry(BLOCK, BLOCK, BLOCK);

    class Chunk {
      constructor(cx, cz) {
        this.cx = cx;
        this.cz = cz;
        this.blocks = new Map();
        this.meshGroup = new THREE.Group();
        this.loaded = false;
      }

      addBlock(x, y, z, typeIndex) {
        const key = posKey(x, y, z);
        if (this.blocks.has(key)) return;
        
        const material = new THREE.MeshLambertMaterial({ color: BLOCK_TYPES[typeIndex].colorTop });
        const mesh = new THREE.Mesh(boxGeo, material);
        mesh.position.set(x + 0.5, y + 0.5, z + 0.5);
        mesh.userData = { typeIndex, chunk: this };
        
        this.meshGroup.add(mesh);
        this.blocks.set(key, mesh);
        allBlocks.set(key, mesh);
      }

      removeBlock(x, y, z) {
        const key = posKey(x, y, z);
        const mesh = this.blocks.get(key);
        if (!mesh) return;
        
        this.meshGroup.remove(mesh);
        this.blocks.delete(key);
        allBlocks.delete(key);
      }

      load() {
        if (this.loaded) return;
        
        const startX = this.cx * CHUNK_SIZE;
        const startZ = this.cz * CHUNK_SIZE;
        const endX = Math.min(startX + CHUNK_SIZE, WORLD_SIZE);
        const endZ = Math.min(startZ + CHUNK_SIZE, WORLD_SIZE);

        // Katmanlı dünya oluşturma
        for (let x = startX; x < endX; x++) {
          for (let z = startZ; z < endZ; z++) {
            for (let y = 0; y < WORLD_HEIGHT; y++) {
              let type;
              if (y === 0) type = 2; // Taş
              else if (y < 3) type = 2; // Taş
              else if (y < 6) type = 1; // Toprak
              else if (y === 6) type = 0; // Çimen
              else continue; // Boşluk

              this.addBlock(x, y, z, type);
            }
          }
        }
        
        scene.add(this.meshGroup);
        this.loaded = true;
        this.generateStructures(startX, startZ, endX, endZ);
      }

      generateStructures(startX, startZ, endX, endZ) {
        // Maden damarları
        const coalCount = Math.floor(Math.random() * 3);
        for (let i = 0; i < coalCount; i++) {
          const x = startX + Math.floor(Math.random() * (endX - startX));
          const z = startZ + Math.floor(Math.random() * (endZ - startZ));
          const y = 3 + Math.floor(Math.random() * 3);
          if (y < WORLD_HEIGHT) {
            this.addBlock(x, y, z, 4);
          }
        }
      }

      unload() {
        if (!this.loaded) return;
        scene.remove(this.meshGroup);
        this.blocks.clear();
        this.loaded = false;
      }
    }

    // Chunk yönetimi
    function getChunkCoords(x, z) {
      return {
        cx: Math.floor(x / CHUNK_SIZE),
        cz: Math.floor(z / CHUNK_SIZE)
      };
    }

    function getChunk(cx, cz) {
      const key = chunkKey(cx, cz);
      if (!chunks.has(key)) {
        const chunk = new Chunk(cx, cz);
        chunks.set(key, chunk);
        return chunk;
      }
      return chunks.get(key);
    }

    function loadChunk(cx, cz) {
      if (cx < 0 || cz < 0 || cx >= CHUNKS_X || cz >= CHUNKS_Z) return;
      const key = chunkKey(cx, cz);
      if (loadedChunks.has(key)) return;
      
      const chunk = getChunk(cx, cz);
      chunk.load();
      loadedChunks.add(key);
    }

    function updateLoadedChunks() {
      const playerChunkX = Math.floor(player.position.x / CHUNK_SIZE);
      const playerChunkZ = Math.floor(player.position.z / CHUNK_SIZE);
      
      for (let cx = playerChunkX - RENDER_DISTANCE; cx <= playerChunkX + RENDER_DISTANCE; cx++) {
        for (let cz = playerChunkZ - RENDER_DISTANCE; cz <= playerChunkZ + RENDER_DISTANCE; cz++) {
          if (cx >= 0 && cz >= 0 && cx < CHUNKS_X && cz < CHUNKS_Z) {
            loadChunk(cx, cz);
          }
        }
      }
    }

    // === Kırılma sistemi ===
    let breakingBlock = null;
    let breakStartTime = 0;
    let breakProgress = 0;
    const breakProgressElement = document.getElementById('break-progress');
    const breakProgressBar = document.getElementById('break-progress-bar');

    function startBreakingBlock(x, y, z) {
      const key = posKey(x, y, z);
      const mesh = allBlocks.get(key);
      if (mesh) {
        breakingBlock = { x, y, z, key, mesh };
        breakStartTime = Date.now();
        breakProgress = 0;
        breakProgressElement.style.display = 'block';
      }
    }

    function stopBreakingBlock() {
      breakingBlock = null;
      breakProgress = 0;
      breakProgressElement.style.display = 'none';
      breakProgressBar.style.width = '0%';
    }

    function updateBreakingProgress() {
      if (!breakingBlock) return false;
      
      const mesh = allBlocks.get(breakingBlock.key);
      if (!mesh) {
        stopBreakingBlock();
        return false;
      }

      const typeIndex = mesh.userData.typeIndex;
      const blockType = BLOCK_TYPES[typeIndex];
      const breakTime = blockType.breakTime * 1000;
      const elapsed = Date.now() - breakStartTime;
      
      breakProgress = Math.min(1, elapsed / breakTime);
      breakProgressBar.style.width = (breakProgress * 100) + '%';

      if (breakProgress >= 1) {
        removeBlock(breakingBlock.x, breakingBlock.y, breakingBlock.z);
        stopBreakingBlock();
        return true;
      }
      return false;
    }

    function removeBlock(x, y, z, fromServer = false) {
      const key = posKey(x, y, z);
      const mesh = allBlocks.get(key);
      if (!mesh) return;

      const chunkCoords = getChunkCoords(x, z);
      const chunk = getChunk(chunkCoords.cx, chunkCoords.cz);
      chunk.removeBlock(x, y, z);
    }

    function addBlock(x, y, z, typeIndex = currentBlockType, fromServer = false) {
      if (y >= WORLD_HEIGHT || y < 0) return;
      
      const chunkCoords = getChunkCoords(x, z);
      const chunk = getChunk(chunkCoords.cx, chunkCoords.cz);
      chunk.addBlock(x, y, z, typeIndex);
    }

    // ===
      // Sunucuya bildir (kendi yaptığımız değişiklik)
      if (!fromServer) {
        sendBlockChange(x, y, z, 'add', typeIndex);
      }
    }
    // Dünya oluştur
    loadInitialChunks();
    generateGlobalStructures();
    // === Kontroller ===
    const keys = { w:false, a:false, s:false, d:false, shift:false };
    // === Envater Sistemi ===
    let inventoryVisible = false;
    let inventoryItems = {};
    let selectedInventorySlot = 0;
    const inventoryElement = document.getElementById('inventory');
    const inventoryGrid = document.getElementById('inventoryGrid');
    function createInventory() {
      inventoryGrid.innerHTML = '';
      for (let i = 0; i < 27; i++) {
        const slot = document.createElement('div');
        slot.className = 'inventory-slot';
        slot.dataset.index = i;
        updateInventorySlot(slot, i);
        slot.addEventListener('click', () => {
          selectInventorySlot(i);
        });
        inventoryGrid.appendChild(slot);
      }
      BLOCK_TYPES.forEach((type, index) => {
        inventoryItems[index] = 16;
      });
      updateInventoryDisplay();
    }
    function updateInventorySlot(slotElement, index) {
      const typeIndex = Math.floor(index / 9);
      const type = BLOCK_TYPES[typeIndex];
      if (type) {
        slotElement.textContent = type.label;
        slotElement.style.backgroundColor = `rgba(${(type.colorTop >> 16) & 0xFF}, ${(type.colorSide >> 8) & 0xFF}, ${type.colorSide & 0xFF}, 0.3)`;
        if (inventoryItems[typeIndex] > 0) {
          const count = document.createElement('div');
          count.className = 'item-count';
          count.textContent = inventoryItems[typeIndex];
          slotElement.appendChild(count);
        }
      }
    }
    function updateInventoryDisplay() {
      const slots = inventoryGrid.querySelectorAll('.inventory-slot');
      slots.forEach((slot, index) => {
        updateInventorySlot(slot, index);
      });
    }
    function selectInventorySlot(index) {
      selectedInventorySlot = index;
      const slots = inventoryGrid.querySelectorAll('.inventory-slot');
      slots.forEach((slot, i) => {
        slot.classList.toggle('selected', i === index);
      });
      const blockTypeIndex = Math.floor(index / 9);
      if (blockTypeIndex < BLOCK_TYPES.length) {
        currentBlockType = blockTypeIndex;
        updateHotbar();
      }
    }
    function toggleInventory() {
      inventoryVisible = !inventoryVisible;
      inventoryElement.classList.toggle('visible', inventoryVisible);
      if (inventoryVisible) {
        if (document.pointerLockElement === renderer.domElement) {
          document.exitPointerLock();
        }
        stopBreakingBlock();
      } else {
        renderer.domElement.requestPointerLock();
      }
    }
    createInventory();
    addEventListener('keydown', e=>{
      if (inventoryVisible) {
        if (e.code === 'KeyE') {
          e.preventDefault();
          toggleInventory();
        } else if (e.code >= 'Digit1' && e.code <= 'Digit9') {
          const slotIndex = parseInt(e.code.replace('Digit', '')) - 1;
          selectInventorySlot(slotIndex);
        }
        return;
      }
      if (e.code === 'KeyW') keys.w = true; 
      else if (e.code === 'KeyA') keys.a = true; 
      else if (e.code === 'KeyS') keys.s = true; 
      else if (e.code === 'KeyD') keys.d = true; 
      else if (e.code === 'ShiftLeft') keys.shift = true;
      else if (e.code === 'Space') { 
        if (canJump) { 
          velocity.y = 12; 
          canJump = false; 
        } 
      }
      else if (e.code === 'Digit1') { currentBlockType = 0; updateHotbar(); } 
      else if (e.code === 'Digit2') { currentBlockType = 1; updateHotbar(); } 
      else if (e.code === 'Digit3') { currentBlockType = 2; updateHotbar(); } 
      else if (e.code === 'Digit4') { currentBlockType = 3; updateHotbar(); }
      else if (e.code === 'Digit5') { currentBlockType = 4; updateHotbar(); }
      else if (e.code === 'Digit6') { currentBlockType = 5; updateHotbar(); }
      else if (e.code === 'Digit7') { currentBlockType = 6; updateHotbar(); }
      else if (e.code === 'Digit8') { currentBlockType = 7; updateHotbar(); }
      else if (e.code === 'KeyG') { 
        scene.fog ? (scene.fog=null) : (scene.fog = new THREE.Fog(0x87ceeb, 20, 60)); 
      }
      else if (e.code === 'KeyR') { 
        const x = Math.floor(player.position.x + (Math.random() - 0.5) * 20);
        const z = Math.floor(player.position.z + (Math.random() - 0.5) * 20);
        addTree(x, z);
      }
      else if (e.code === 'KeyE') { 
        e.preventDefault();
        toggleInventory(); 
      }
      else if (e.code === 'KeyQ') {
        e.preventDefault();
        toggleAttackMode();
      }
    });
    addEventListener('keyup', e=>{
      if (inventoryVisible) return;
      if (e.code === 'KeyW') keys.w = false; 
      else if (e.code === 'KeyA') keys.a = false; 
      else if (e.code === 'KeyS') keys.s = false; 
      else if (e.code === 'KeyD') keys.d = false; 
      else if (e.code === 'ShiftLeft') keys.shift = false;
    });
    // Saldırı modu geçişi
    function toggleAttackMode() {
      attackMode = !attackMode;
      swordMesh.visible = attackMode;
      attackModeIndicator.style.display = attackMode ? 'block' : 'none';
      // Oyuncu rengini değiştir
      if (attackMode) {
        // Saldırı modundayken kendi rengini değiştir
        // Bu örnekte sadece kılıcı gösteriyoruz
      }
      // Sunucuya saldırı modu değişikliğini bildir
      sendPlayerPosition();
    }
    let lookActive = false, movedDuringDrag = false, lastX = 0, lastY = 0, yaw = 0, pitch = 0;
    let mouseDown = false;
    renderer.domElement.addEventListener('mousedown', (e)=>{
      if (inventoryVisible) return;
      if (e.button === 0) {
        if (attackMode) {
          // Saldırı modundaysa saldır
          sendAttack();
        } else {
          // Normal moddaysa blok kır
          mouseDown = true;
          const hit = getTargetBlock();
          if (hit) {
            startBreakingBlock(hit.x, hit.y, hit.z);
          }
        }
      }
      lookActive = true; 
      movedDuringDrag = false; 
      lastX = e.clientX; 
      lastY = e.clientY; 
    });
    addEventListener('mouseup', (e)=>{
      if (inventoryVisible) return;
      if (e.button === 0) {
        mouseDown = false;
        stopBreakingBlock();
      }
      if (!movedDuringDrag && e.button !== 0) handleBlockClick(e); 
      lookActive = false; 
    });
    addEventListener('mousemove', (e)=>{
      if (inventoryVisible || !lookActive) return;
      const dx = e.clientX - lastX; 
      const dy = e.clientY - lastY;
      if (Math.abs(dx) > 1 || Math.abs(dy) > 1) movedDuringDrag = true;
      lastX = e.clientX; 
      lastY = e.clientY;
      yaw -= dx * 0.0028; 
      pitch -= dy * 0.0028;
      pitch = Math.max(-Math.PI/2 + 0.05, Math.min(Math.PI/2 - 0.05, pitch));
      player.rotation.y = yaw; 
      camera.rotation.x = pitch;
    });
    addEventListener('contextmenu', e=> e.preventDefault());
    // === Blok kır/yerleştir ===
    const raycaster = new THREE.Raycaster();
    function getTargetBlock(){
      raycaster.setFromCamera({x:0, y:0}, camera);
      const intersects = raycaster.intersectObjects([...allBlocks.values()], false);
      if (intersects.length > 0) {
        const inter = intersects[0];
        const p = inter.object.position.clone().addScalar(-0.5);
        return { 
          x: Math.round(p.x), 
          y: Math.round(p.y), 
          z: Math.round(p.z), 
          normal: inter.face.normal.clone() 
        };
      }
      return null;
    }
    function handleBlockClick(e){
      if (inventoryVisible) return;
      const hit = getTargetBlock();
      if (!hit) return;
      if (e.button === 2){
        const nx = hit.x + hit.normal.x, 
              ny = hit.y + hit.normal.y, 
              nz = hit.z + hit.normal.z;
        const playerBox = new THREE.Box3().setFromCenterAndSize(
          player.position, 
          new THREE.Vector3(0.6, 1.6, 0.6)
        );
        const blockBox = new THREE.Box3().setFromCenterAndSize(
          new THREE.Vector3(nx+0.5, ny+0.5, nz+0.5), 
          new THREE.Vector3(1,1,1)
        );
        if(!playerBox.intersectsBox(blockBox) && ny < WORLD_HEIGHT && ny >= 0) {
          addBlock(nx, ny, nz, currentBlockType);
        }
      }
    }
    function isBlockAt(x, y, z) {
      return allBlocks.has(posKey(Math.floor(x), Math.floor(y), Math.floor(z)));
    }
    // === Fizik/yer çekimi ve hareket ===
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const up = new THREE.Vector3(0,1,0);
    let canJump = false;
    const clock = new THREE.Clock();
    // Debug bilgisi
    const fpsCounter = document.getElementById('fps-counter');
    const chunkCounter = document.getElementById('chunk-counter');
    const blockCounter = document.getElementById('block-counter');
    let frameCount = 0;
    let lastFpsUpdate = 0;
    function animate(){
      requestAnimationFrame(animate);
      if (inventoryVisible) {
        renderer.render(scene, camera);
        return;
      }
      const delta = Math.min(0.05, clock.getDelta());
      const elapsedTime = clock.getElapsedTime();
      // FPS hesaplama
      frameCount++;
      if (elapsedTime - lastFpsUpdate >= 1) {
        fpsCounter.textContent = frameCount;
        chunkCounter.textContent = loadedChunks.size;
        blockCounter.textContent = allBlocks.size;
        frameCount = 0;
        lastFpsUpdate = elapsedTime;
      }
      // Chunk sistemini güncelle
      updateLoadedChunks();
      // Kırılma ilerlemesini güncelle
      if (mouseDown && breakingBlock) {
        updateBreakingProgress();
      }
      // Düşen eşyaları güncelle
      updateDroppedItems(delta);
      // Pozisyon gönderimi
      sendPlayerPosition();
      // Yürüme yönü
      const forward = new THREE.Vector3(0,0,-1).applyAxisAngle(up, yaw);
      const right = new THREE.Vector3().crossVectors(up, forward);
      direction.set(0,0,0);
      if (keys.w) direction.add(forward); 
      if (keys.s) direction.sub(forward);
      if (keys.a) direction.add(right); 
      if (keys.d) direction.sub(right);
      if (direction.lengthSq() > 0) direction.normalize();
      const speed = (keys.shift ? 8 : 4);
      velocity.x = direction.x * speed;
      velocity.z = direction.z * speed;
      velocity.y -= 20 * delta;
      // Çarpışma fiziği
      const playerWidth = 0.2;
      const playerHeight = 1.5;
      const pos = player.position;
      const newX = pos.x + velocity.x * delta;
      if (!isBlockAt(newX + (velocity.x > 0 ? playerWidth : -playerWidth), pos.y, pos.z) &&
          !isBlockAt(newX + (velocity.x > 0 ? playerWidth : -playerWidth), pos.y + 1, pos.z)) {
        pos.x = newX;
      }
      const newZ = pos.z + velocity.z * delta;
      if (!isBlockAt(pos.x, pos.y, newZ + (velocity.z > 0 ? playerWidth : -playerWidth)) &&
          !isBlockAt(pos.x, pos.y + 1, newZ + (velocity.z > 0 ? playerWidth : -playerWidth))) {
        pos.z = newZ;
      }
      const newY = pos.y + velocity.y * delta;
      if (velocity.y <= 0) {
        const footY = newY;
        if (isBlockAt(pos.x, footY, pos.z)) {
          pos.y = Math.floor(footY) + 1;
          velocity.y = 0;
          canJump = true;
        } else {
          pos.y = newY;
        }
      } else {
        const headY = newY + playerHeight;
        if (isBlockAt(pos.x, headY, pos.z)) {
          pos.y = Math.floor(headY) - playerHeight;
          velocity.y = 0;
        } else {
          pos.y = newY;
        }
      }
      // Blok vurgulama
      const target = getTargetBlock();
      if (target) {
        highlightMesh.position.set(target.x + 0.5, target.y + 0.5, target.z + 0.5);
        highlightMesh.visible = true;
      } else {
        highlightMesh.visible = false;
      }
      renderer.render(scene, camera);
    }
    // === Düşen eşyaları güncelleme ===
    function updateDroppedItems(delta) {
      const currentTime = Date.now();
      const pickupDistance = 1.5;
      const playerPos = player.position.clone();
      for (const [itemId, itemMesh] of droppedItems) {
        const userData = itemMesh.userData;
        if (currentTime - userData.createdAt > 20000) {
          removeDroppedItem(itemId);
          continue;
        }
        userData.velocity.y -= 15 * delta;
        itemMesh.position.add(userData.velocity.clone().multiplyScalar(delta));
        const groundY = Math.floor(itemMesh.position.y - 0.15);
        if (isBlockAt(itemMesh.position.x, groundY, itemMesh.position.z)) {
          itemMesh.position.y = groundY + 1.15;
          userData.velocity.y = 0;
          userData.velocity.x *= 0.7;
          userData.velocity.z *= 0.7;
        }
        const distanceToPlayer = itemMesh.position.distanceTo(playerPos);
        if (distanceToPlayer < pickupDistance) {
          removeDroppedItem(itemId);
        }
        itemMesh.rotation.x += delta;
        itemMesh.rotation.y += delta;
      }
    }
    // Sunucuya bağlan
    connectToServer();
    animate();
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>



